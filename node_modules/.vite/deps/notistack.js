import { r as __toESM, t as require_react } from "./react-CcqPggiU.js";
import { t as require_react_dom } from "./react-dom-DMqAYKIE.js";

//#region node_modules/clsx/dist/clsx.m.js
var import_react_dom = require_react_dom();
var import_react = /* @__PURE__ */ __toESM(require_react());
function r$1(e$1) {
	var t$1, f$1, n$1 = "";
	if ("string" == typeof e$1 || "number" == typeof e$1) n$1 += e$1;
	else if ("object" == typeof e$1) if (Array.isArray(e$1)) for (t$1 = 0; t$1 < e$1.length; t$1++) e$1[t$1] && (f$1 = r$1(e$1[t$1])) && (n$1 && (n$1 += " "), n$1 += f$1);
	else for (t$1 in e$1) e$1[t$1] && (n$1 && (n$1 += " "), n$1 += t$1);
	return n$1;
}
function clsx() {
	for (var e$1, t$1, f$1 = 0, n$1 = ""; f$1 < arguments.length;) (e$1 = arguments[f$1++]) && (t$1 = r$1(e$1)) && (n$1 && (n$1 += " "), n$1 += t$1);
	return n$1;
}
var clsx_m_default = clsx;

//#endregion
//#region node_modules/goober/dist/goober.modern.js
var e = { data: "" }, t = (t$1) => {
	if ("object" == typeof window) {
		let e$1 = (t$1 ? t$1.querySelector("#_goober") : window._goober) || Object.assign(document.createElement("style"), {
			innerHTML: " ",
			id: "_goober"
		});
		return e$1.nonce = window.__nonce__, e$1.parentNode || (t$1 || document.head).appendChild(e$1), e$1.firstChild;
	}
	return t$1 || e;
}, r = (e$1) => {
	let r$2 = t(e$1), l$1 = r$2.data;
	return r$2.data = "", l$1;
}, l = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a = /\/\*[^]*?\*\/|  +/g, n = /\n+/g, o = (e$1, t$1) => {
	let r$2 = "", l$1 = "", a$1 = "";
	for (let n$1 in e$1) {
		let c$1 = e$1[n$1];
		"@" == n$1[0] ? "i" == n$1[1] ? r$2 = n$1 + " " + c$1 + ";" : l$1 += "f" == n$1[1] ? o(c$1, n$1) : n$1 + "{" + o(c$1, "k" == n$1[1] ? "" : t$1) + "}" : "object" == typeof c$1 ? l$1 += o(c$1, t$1 ? t$1.replace(/([^,])+/g, (e$2) => n$1.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (t$2) => /&/.test(t$2) ? t$2.replace(/&/g, e$2) : e$2 ? e$2 + " " + t$2 : t$2)) : n$1) : null != c$1 && (n$1 = /^--/.test(n$1) ? n$1 : n$1.replace(/[A-Z]/g, "-$&").toLowerCase(), a$1 += o.p ? o.p(n$1, c$1) : n$1 + ":" + c$1 + ";");
	}
	return r$2 + (t$1 && a$1 ? t$1 + "{" + a$1 + "}" : a$1) + l$1;
}, c = {}, s = (e$1) => {
	if ("object" == typeof e$1) {
		let t$1 = "";
		for (let r$2 in e$1) t$1 += r$2 + s(e$1[r$2]);
		return t$1;
	}
	return e$1;
}, i = (e$1, t$1, r$2, i$1, p$1) => {
	let u$1 = s(e$1), d$1 = c[u$1] || (c[u$1] = ((e$2) => {
		let t$2 = 0, r$3 = 11;
		for (; t$2 < e$2.length;) r$3 = 101 * r$3 + e$2.charCodeAt(t$2++) >>> 0;
		return "go" + r$3;
	})(u$1));
	if (!c[d$1]) {
		let t$2 = u$1 !== e$1 ? e$1 : ((e$2) => {
			let t$3, r$3, o$1 = [{}];
			for (; t$3 = l.exec(e$2.replace(a, ""));) t$3[4] ? o$1.shift() : t$3[3] ? (r$3 = t$3[3].replace(n, " ").trim(), o$1.unshift(o$1[0][r$3] = o$1[0][r$3] || {})) : o$1[0][t$3[1]] = t$3[2].replace(n, " ").trim();
			return o$1[0];
		})(e$1);
		c[d$1] = o(p$1 ? { ["@keyframes " + d$1]: t$2 } : t$2, r$2 ? "" : "." + d$1);
	}
	let f$1 = r$2 && c.g ? c.g : null;
	return r$2 && (c.g = c[d$1]), ((e$2, t$2, r$3, l$1) => {
		l$1 ? t$2.data = t$2.data.replace(l$1, e$2) : -1 === t$2.data.indexOf(e$2) && (t$2.data = r$3 ? e$2 + t$2.data : t$2.data + e$2);
	})(c[d$1], t$1, i$1, f$1), d$1;
}, p = (e$1, t$1, r$2) => e$1.reduce((e$2, l$1, a$1) => {
	let n$1 = t$1[a$1];
	if (n$1 && n$1.call) {
		let e$3 = n$1(r$2), t$2 = e$3 && e$3.props && e$3.props.className || /^go/.test(e$3) && e$3;
		n$1 = t$2 ? "." + t$2 : e$3 && "object" == typeof e$3 ? e$3.props ? "" : o(e$3, "") : !1 === e$3 ? "" : e$3;
	}
	return e$2 + l$1 + (null == n$1 ? "" : n$1);
}, "");
function u(e$1) {
	let r$2 = this || {}, l$1 = e$1.call ? e$1(r$2.p) : e$1;
	return i(l$1.unshift ? l$1.raw ? p(l$1, [].slice.call(arguments, 1), r$2.p) : l$1.reduce((e$2, t$1) => Object.assign(e$2, t$1 && t$1.call ? t$1(r$2.p) : t$1), {}) : l$1, t(r$2.target), r$2.g, r$2.o, r$2.k);
}
var d, f, g, b = u.bind({ g: 1 }), h = u.bind({ k: 1 });

//#endregion
//#region node_modules/notistack/notistack.esm.js
function _defineProperties(target, props) {
	for (var i$1 = 0; i$1 < props.length; i$1++) {
		var descriptor = props[i$1];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, descriptor.key, descriptor);
	}
}
function _createClass(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties(Constructor, staticProps);
	return Constructor;
}
function _extends() {
	_extends = Object.assign || function(target) {
		for (var i$1 = 1; i$1 < arguments.length; i$1++) {
			var source = arguments[i$1];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
	subClass.prototype = Object.create(superClass.prototype);
	subClass.prototype.constructor = subClass;
	subClass.__proto__ = superClass;
}
function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i$1;
	for (i$1 = 0; i$1 < sourceKeys.length; i$1++) {
		key = sourceKeys[i$1];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _assertThisInitialized(self) {
	if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self;
}
var noOp = function noOp$2() {
	return "";
};
var SnackbarContext = /* @__PURE__ */ import_react.createContext({
	enqueueSnackbar: noOp,
	closeSnackbar: noOp
});
var breakpoints = {
	downXs: "@media (max-width:599.95px)",
	upSm: "@media (min-width:600px)"
};
var capitalise = function capitalise$1(text) {
	return text.charAt(0).toUpperCase() + text.slice(1);
};
var originKeyExtractor = function originKeyExtractor$1(anchor) {
	return "" + capitalise(anchor.vertical) + capitalise(anchor.horizontal);
};
var isDefined = function isDefined$1(value) {
	return !!value || value === 0;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
	_inheritsLoose(Transition$1, _React$Component);
	function Transition$1(props) {
		var _this = _React$Component.call(this, props) || this;
		var appear = props.appear;
		var initialStatus;
		_this.appearStatus = null;
		if (props["in"]) if (appear) {
			initialStatus = EXITED;
			_this.appearStatus = ENTERING;
		} else initialStatus = ENTERED;
		else if (props.unmountOnExit || props.mountOnEnter) initialStatus = UNMOUNTED;
		else initialStatus = EXITED;
		_this.state = { status: initialStatus };
		_this.nextCallback = null;
		return _this;
	}
	Transition$1.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
		if (_ref["in"] && prevState.status === UNMOUNTED) return { status: EXITED };
		return null;
	};
	var _proto = Transition$1.prototype;
	_proto.componentDidMount = function componentDidMount() {
		this.updateStatus(true, this.appearStatus);
	};
	_proto.componentDidUpdate = function componentDidUpdate(prevProps) {
		var nextStatus = null;
		if (prevProps !== this.props) {
			var status = this.state.status;
			if (this.props["in"]) {
				if (status !== ENTERING && status !== ENTERED) nextStatus = ENTERING;
			} else if (status === ENTERING || status === ENTERED) nextStatus = EXITING;
		}
		this.updateStatus(false, nextStatus);
	};
	_proto.componentWillUnmount = function componentWillUnmount() {
		this.cancelNextCallback();
	};
	_proto.getTimeouts = function getTimeouts() {
		var timeout$1 = this.props.timeout;
		var enter = timeout$1;
		var exit = timeout$1;
		if (timeout$1 != null && typeof timeout$1 !== "number" && typeof timeout$1 !== "string") {
			exit = timeout$1.exit;
			enter = timeout$1.enter;
		}
		return {
			exit,
			enter
		};
	};
	_proto.updateStatus = function updateStatus(mounting, nextStatus) {
		if (mounting === void 0) mounting = false;
		if (nextStatus !== null) {
			this.cancelNextCallback();
			if (nextStatus === ENTERING) this.performEnter(mounting);
			else this.performExit();
		} else if (this.props.unmountOnExit && this.state.status === EXITED) this.setState({ status: UNMOUNTED });
	};
	_proto.performEnter = function performEnter(mounting) {
		var _this2 = this;
		var enter = this.props.enter;
		var isAppearing = mounting;
		var timeouts = this.getTimeouts();
		if (!mounting && !enter) {
			this.safeSetState({ status: ENTERED }, function() {
				if (_this2.props.onEntered) _this2.props.onEntered(_this2.node, isAppearing);
			});
			return;
		}
		if (this.props.onEnter) this.props.onEnter(this.node, isAppearing);
		this.safeSetState({ status: ENTERING }, function() {
			if (_this2.props.onEntering) _this2.props.onEntering(_this2.node, isAppearing);
			_this2.onTransitionEnd(timeouts.enter, function() {
				_this2.safeSetState({ status: ENTERED }, function() {
					if (_this2.props.onEntered) _this2.props.onEntered(_this2.node, isAppearing);
				});
			});
		});
	};
	_proto.performExit = function performExit() {
		var _this3 = this;
		var exit = this.props.exit;
		var timeouts = this.getTimeouts();
		if (!exit) {
			this.safeSetState({ status: EXITED }, function() {
				if (_this3.props.onExited) _this3.props.onExited(_this3.node);
			});
			return;
		}
		if (this.props.onExit) this.props.onExit(this.node);
		this.safeSetState({ status: EXITING }, function() {
			if (_this3.props.onExiting) _this3.props.onExiting(_this3.node);
			_this3.onTransitionEnd(timeouts.exit, function() {
				_this3.safeSetState({ status: EXITED }, function() {
					if (_this3.props.onExited) _this3.props.onExited(_this3.node);
				});
			});
		});
	};
	_proto.cancelNextCallback = function cancelNextCallback() {
		if (this.nextCallback !== null && this.nextCallback.cancel) {
			this.nextCallback.cancel();
			this.nextCallback = null;
		}
	};
	_proto.safeSetState = function safeSetState(nextState, callback) {
		callback = this.setNextCallback(callback);
		this.setState(nextState, callback);
	};
	_proto.setNextCallback = function setNextCallback(callback) {
		var _this4 = this;
		var active = true;
		this.nextCallback = function() {
			if (active) {
				active = false;
				_this4.nextCallback = null;
				callback();
			}
		};
		this.nextCallback.cancel = function() {
			active = false;
		};
		return this.nextCallback;
	};
	_proto.onTransitionEnd = function onTransitionEnd(timeout$1, handler) {
		this.setNextCallback(handler);
		var doesNotHaveTimeoutOrListener = timeout$1 == null && !this.props.addEndListener;
		if (!this.node || doesNotHaveTimeoutOrListener) {
			setTimeout(this.nextCallback, 0);
			return;
		}
		if (this.props.addEndListener) this.props.addEndListener(this.node, this.nextCallback);
		if (timeout$1 != null) setTimeout(this.nextCallback, timeout$1);
	};
	_proto.render = function render() {
		var status = this.state.status;
		if (status === UNMOUNTED) return null;
		var _this$props = this.props, children = _this$props.children;
		return children(status, _objectWithoutPropertiesLoose(_this$props, [
			"children",
			"in",
			"mountOnEnter",
			"unmountOnExit",
			"appear",
			"enter",
			"exit",
			"timeout",
			"addEndListener",
			"onEnter",
			"onEntering",
			"onEntered",
			"onExit",
			"onExiting",
			"onExited",
			"nodeRef"
		]));
	};
	_createClass(Transition$1, [{
		key: "node",
		get: function get() {
			var _this$props$nodeRef;
			var node = (_this$props$nodeRef = this.props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current;
			if (!node) throw new Error("notistack - Custom snackbar is not refForwarding");
			return node;
		}
	}]);
	return Transition$1;
}(import_react.Component);
function noop() {}
Transition.defaultProps = {
	"in": false,
	mountOnEnter: false,
	unmountOnExit: false,
	appear: false,
	enter: true,
	exit: true,
	onEnter: noop,
	onEntering: noop,
	onEntered: noop,
	onExit: noop,
	onExiting: noop,
	onExited: noop
};
/**
* Credit to MUI team @ https://mui.com
*/
/**
* passes {value} to {ref}
*
* Useful if you want to expose the ref of an inner component to the public API
* while still using it inside the component.
* @param ref A ref callback or ref object. If anything falsy, this is a no-op.
*/
function setRef(ref, value) {
	if (typeof ref === "function") ref(value);
	else if (ref) ref.current = value;
}
function useForkRef(refA, refB) {
	/**
	* This will create a new function if the ref props change and are defined.
	* This means react will call the old forkRef with `null` and the new forkRef
	* with the ref. Cleanup naturally emerges from this behavior.
	*/
	return (0, import_react.useMemo)(function() {
		if (refA == null && refB == null) return null;
		return function(refValue) {
			setRef(refA, refValue);
			setRef(refB, refValue);
		};
	}, [refA, refB]);
}
function getTransitionProps(props) {
	var timeout$1 = props.timeout, _props$style = props.style, style = _props$style === void 0 ? {} : _props$style, mode = props.mode;
	return {
		duration: typeof timeout$1 === "object" ? timeout$1[mode] || 0 : timeout$1,
		easing: style.transitionTimingFunction,
		delay: style.transitionDelay
	};
}
/**
* Credit to MUI team @ https://mui.com
*/
var defaultEasing = {
	easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
	easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
	easeIn: "cubic-bezier(0.4, 0, 1, 1)",
	sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
/**
* CSS hack to force a repaint
*/
var reflow = function reflow$1(node) {
	node.scrollTop = node.scrollTop;
};
var formatMs = function formatMs$1(milliseconds) {
	return Math.round(milliseconds) + "ms";
};
function createTransition(props, options) {
	if (props === void 0) props = ["all"];
	var _ref = options || {}, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 300 : _ref$duration, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? defaultEasing.easeInOut : _ref$easing, _ref$delay = _ref.delay, delay = _ref$delay === void 0 ? 0 : _ref$delay;
	return (Array.isArray(props) ? props : [props]).map(function(animatedProp) {
		var formattedDuration = typeof duration === "string" ? duration : formatMs(duration);
		var formattedDelay = typeof delay === "string" ? delay : formatMs(delay);
		return animatedProp + " " + formattedDuration + " " + easing + " " + formattedDelay;
	}).join(",");
}
function ownerDocument(node) {
	return node && node.ownerDocument || document;
}
function ownerWindow(node) {
	return ownerDocument(node).defaultView || window;
}
/**
* Corresponds to 10 frames at 60 Hz.
* A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.
*/
function debounce(func, wait) {
	if (wait === void 0) wait = 166;
	var timeout$1;
	function debounced() {
		var _this = this;
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		var later = function later$1() {
			func.apply(_this, args);
		};
		clearTimeout(timeout$1);
		timeout$1 = setTimeout(later, wait);
	}
	debounced.clear = function() {
		clearTimeout(timeout$1);
	};
	return debounced;
}
/**
* Translate the node so it can't be seen on the screen.
* Later, we're going to translate the node back to its original location with `none`.
*/
function getTranslateValue(direction$1, node) {
	var rect = node.getBoundingClientRect();
	var containerWindow = ownerWindow(node);
	var transform;
	if (node.fakeTransform) transform = node.fakeTransform;
	else {
		var computedStyle = containerWindow.getComputedStyle(node);
		transform = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
	}
	var offsetX = 0;
	var offsetY = 0;
	if (transform && transform !== "none" && typeof transform === "string") {
		var transformValues = transform.split("(")[1].split(")")[0].split(",");
		offsetX = parseInt(transformValues[4], 10);
		offsetY = parseInt(transformValues[5], 10);
	}
	switch (direction$1) {
		case "left": return "translateX(" + (containerWindow.innerWidth + offsetX - rect.left) + "px)";
		case "right": return "translateX(-" + (rect.left + rect.width - offsetX) + "px)";
		case "up": return "translateY(" + (containerWindow.innerHeight + offsetY - rect.top) + "px)";
		default: return "translateY(-" + (rect.top + rect.height - offsetY) + "px)";
	}
}
function setTranslateValue(direction$1, node) {
	if (!node) return;
	var transform = getTranslateValue(direction$1, node);
	if (transform) {
		node.style.webkitTransform = transform;
		node.style.transform = transform;
	}
}
var Slide = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
	var children = props.children, _props$direction = props.direction, direction$1 = _props$direction === void 0 ? "down" : _props$direction, inProp = props["in"], style = props.style, _props$timeout = props.timeout, timeout$1 = _props$timeout === void 0 ? 0 : _props$timeout, onEnter = props.onEnter, onEntered = props.onEntered, onExit = props.onExit, onExited = props.onExited, other = _objectWithoutPropertiesLoose(props, [
		"children",
		"direction",
		"in",
		"style",
		"timeout",
		"onEnter",
		"onEntered",
		"onExit",
		"onExited"
	]);
	var nodeRef = (0, import_react.useRef)(null);
	var handleRef = useForkRef(useForkRef(children.ref, nodeRef), ref);
	var handleEnter = function handleEnter$1(node, isAppearing) {
		setTranslateValue(direction$1, node);
		reflow(node);
		if (onEnter) onEnter(node, isAppearing);
	};
	var handleEntering = function handleEntering$1(node) {
		var easing = (style === null || style === void 0 ? void 0 : style.transitionTimingFunction) || defaultEasing.easeOut;
		var transitionProps = getTransitionProps({
			timeout: timeout$1,
			mode: "enter",
			style: _extends({}, style, { transitionTimingFunction: easing })
		});
		node.style.webkitTransition = createTransition("-webkit-transform", transitionProps);
		node.style.transition = createTransition("transform", transitionProps);
		node.style.webkitTransform = "none";
		node.style.transform = "none";
	};
	var handleExit = function handleExit$1(node) {
		var easing = (style === null || style === void 0 ? void 0 : style.transitionTimingFunction) || defaultEasing.sharp;
		var transitionProps = getTransitionProps({
			timeout: timeout$1,
			mode: "exit",
			style: _extends({}, style, { transitionTimingFunction: easing })
		});
		node.style.webkitTransition = createTransition("-webkit-transform", transitionProps);
		node.style.transition = createTransition("transform", transitionProps);
		setTranslateValue(direction$1, node);
		if (onExit) onExit(node);
	};
	var handleExited = function handleExited$1(node) {
		node.style.webkitTransition = "";
		node.style.transition = "";
		if (onExited) onExited(node);
	};
	var updatePosition = (0, import_react.useCallback)(function() {
		if (nodeRef.current) setTranslateValue(direction$1, nodeRef.current);
	}, [direction$1]);
	(0, import_react.useEffect)(function() {
		if (inProp || direction$1 === "down" || direction$1 === "right") return;
		var handleResize = debounce(function() {
			if (nodeRef.current) setTranslateValue(direction$1, nodeRef.current);
		});
		var containerWindow = ownerWindow(nodeRef.current);
		containerWindow.addEventListener("resize", handleResize);
		return function() {
			handleResize.clear();
			containerWindow.removeEventListener("resize", handleResize);
		};
	}, [direction$1, inProp]);
	(0, import_react.useEffect)(function() {
		if (!inProp) updatePosition();
	}, [inProp, updatePosition]);
	return (0, import_react.createElement)(Transition, Object.assign({
		appear: true,
		nodeRef,
		onEnter: handleEnter,
		onEntered,
		onEntering: handleEntering,
		onExit: handleExit,
		onExited: handleExited,
		"in": inProp,
		timeout: timeout$1
	}, other), function(state, childProps) {
		return (0, import_react.cloneElement)(children, _extends({
			ref: handleRef,
			style: _extends({ visibility: state === "exited" && !inProp ? "hidden" : void 0 }, style, {}, children.props.style)
		}, childProps));
	});
});
Slide.displayName = "Slide";
var SvgIcon = function SvgIcon$1(props) {
	return import_react.createElement("svg", Object.assign({
		viewBox: "0 0 24 24",
		focusable: "false",
		style: {
			fontSize: 20,
			marginInlineEnd: 8,
			userSelect: "none",
			width: "1em",
			height: "1em",
			display: "inline-block",
			fill: "currentColor",
			flexShrink: 0
		}
	}, props));
};
var CheckIcon = function CheckIcon$1() {
	return import_react.createElement(SvgIcon, null, import_react.createElement("path", { d: "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41\n        10.59L10 14.17L17.59 6.58L19 8L10 17Z" }));
};
var WarningIcon = function WarningIcon$1() {
	return import_react.createElement(SvgIcon, null, import_react.createElement("path", { d: "M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z" }));
};
var ErrorIcon = function ErrorIcon$1() {
	return import_react.createElement(SvgIcon, null, import_react.createElement("path", { d: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,\n        6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,\n        13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z" }));
};
var InfoIcon = function InfoIcon$1() {
	return import_react.createElement(SvgIcon, null, import_react.createElement("path", { d: "M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,\n        0 22,12A10,10 0 0,0 12,2Z" }));
};
var defaults = {
	maxSnack: 3,
	persist: false,
	hideIconVariant: false,
	disableWindowBlurListener: false,
	variant: "default",
	autoHideDuration: 5e3,
	iconVariant: {
		"default": void 0,
		success: /* @__PURE__ */ import_react.createElement(CheckIcon, null),
		warning: /* @__PURE__ */ import_react.createElement(WarningIcon, null),
		error: /* @__PURE__ */ import_react.createElement(ErrorIcon, null),
		info: /* @__PURE__ */ import_react.createElement(InfoIcon, null)
	},
	anchorOrigin: {
		vertical: "bottom",
		horizontal: "left"
	},
	TransitionComponent: Slide,
	transitionDuration: {
		enter: 225,
		exit: 195
	}
};
/**
* Derives the right autoHideDuration taking into account the following
* prority order: 1: Options, 2: Props, 3: default fallback
*/
var getAutoHideDuration = function getAutoHideDuration$1(optionsDuration, propsDuration) {
	var isNumberOrNull = function isNumberOrNull$1(numberish) {
		return typeof numberish === "number" || numberish === null;
	};
	if (isNumberOrNull(optionsDuration)) return optionsDuration;
	if (isNumberOrNull(propsDuration)) return propsDuration;
	return defaults.autoHideDuration;
};
/**
* Derives the right transitionDuration taking into account the following
* prority order: 1: Options, 2: Props, 3: default fallback
*/
var getTransitionDuration = function getTransitionDuration$1(optionsDuration, propsDuration) {
	var is = function is$1(item, types) {
		return types.some(function(t$1) {
			return typeof item === t$1;
		});
	};
	if (is(optionsDuration, ["string", "number"])) return optionsDuration;
	if (is(optionsDuration, ["object"])) return _extends({}, defaults.transitionDuration, {}, is(propsDuration, ["object"]) && propsDuration, {}, optionsDuration);
	if (is(propsDuration, ["string", "number"])) return propsDuration;
	if (is(propsDuration, ["object"])) return _extends({}, defaults.transitionDuration, {}, propsDuration);
	return defaults.transitionDuration;
};
var merge = function merge$1(options, props) {
	return function(name, shouldObjectMerge) {
		if (shouldObjectMerge === void 0) shouldObjectMerge = false;
		if (shouldObjectMerge) return _extends({}, defaults[name], {}, props[name], {}, options[name]);
		if (name === "autoHideDuration") return getAutoHideDuration(options.autoHideDuration, props.autoHideDuration);
		if (name === "transitionDuration") return getTransitionDuration(options.transitionDuration, props.transitionDuration);
		return options[name] || props[name] || defaults[name];
	};
};
function makeStyles(styles$2) {
	return Object.entries(styles$2).reduce(function(acc, _ref) {
		var _extends2;
		var key = _ref[0], value = _ref[1];
		return _extends({}, acc, (_extends2 = {}, _extends2[key] = u(value), _extends2));
	}, {});
}
var ComponentClasses = {
	SnackbarContainer: "notistack-SnackbarContainer",
	Snackbar: "notistack-Snackbar",
	CollapseWrapper: "notistack-CollapseWrapper",
	MuiContent: "notistack-MuiContent",
	MuiContentVariant: function MuiContentVariant(variant) {
		return "notistack-MuiContent-" + variant;
	}
};
var classes = /* @__PURE__ */ makeStyles({
	root: { height: 0 },
	entered: { height: "auto" }
});
var collapsedSize = "0px";
var timeout = 175;
var Collapse = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
	var children = props.children, inProp = props["in"], onExited = props.onExited;
	var wrapperRef = (0, import_react.useRef)(null);
	var nodeRef = (0, import_react.useRef)(null);
	var handleRef = useForkRef(ref, nodeRef);
	var getWrapperSize = function getWrapperSize$1() {
		return wrapperRef.current ? wrapperRef.current.clientHeight : 0;
	};
	var handleEnter = function handleEnter$1(node) {
		node.style.height = collapsedSize;
	};
	var handleEntering = function handleEntering$1(node) {
		var wrapperSize = getWrapperSize();
		var _getTransitionProps = getTransitionProps({
			timeout,
			mode: "enter"
		}), transitionDuration = _getTransitionProps.duration, easing = _getTransitionProps.easing;
		node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : transitionDuration + "ms";
		node.style.height = wrapperSize + "px";
		node.style.transitionTimingFunction = easing || "";
	};
	var handleEntered = function handleEntered$1(node) {
		node.style.height = "auto";
	};
	var handleExit = function handleExit$1(node) {
		node.style.height = getWrapperSize() + "px";
	};
	var handleExiting = function handleExiting$1(node) {
		reflow(node);
		var _getTransitionProps2 = getTransitionProps({
			timeout,
			mode: "exit"
		}), transitionDuration = _getTransitionProps2.duration, easing = _getTransitionProps2.easing;
		node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : transitionDuration + "ms";
		node.style.height = collapsedSize;
		node.style.transitionTimingFunction = easing || "";
	};
	return (0, import_react.createElement)(Transition, {
		"in": inProp,
		unmountOnExit: true,
		onEnter: handleEnter,
		onEntered: handleEntered,
		onEntering: handleEntering,
		onExit: handleExit,
		onExited,
		onExiting: handleExiting,
		nodeRef,
		timeout
	}, function(state, childProps) {
		return (0, import_react.createElement)("div", Object.assign({
			ref: handleRef,
			className: clsx_m_default(classes.root, state === "entered" && classes.entered),
			style: _extends({
				pointerEvents: "all",
				overflow: "hidden",
				minHeight: collapsedSize,
				transition: createTransition("height")
			}, state === "entered" && { overflow: "visible" }, {}, state === "exited" && !inProp && { visibility: "hidden" })
		}, childProps), (0, import_react.createElement)("div", {
			ref: wrapperRef,
			className: ComponentClasses.CollapseWrapper,
			style: {
				display: "flex",
				width: "100%"
			}
		}, children));
	});
});
Collapse.displayName = "Collapse";
var direction = {
	right: "left",
	left: "right",
	bottom: "up",
	top: "down"
};
var getSlideDirection = function getSlideDirection$1(anchorOrigin) {
	if (anchorOrigin.horizontal !== "center") return direction[anchorOrigin.horizontal];
	return direction[anchorOrigin.vertical];
};
/** Tranforms classes name */
var toSnackbarAnchorOrigin = function toSnackbarAnchorOrigin$1(anchorOrigin) {
	return "anchorOrigin" + originKeyExtractor(anchorOrigin);
};
/**
* Omit SnackbarContainer class keys that are not needed for SnackbarItem
*/
var keepSnackbarClassKeys = function keepSnackbarClassKeys$1(classes$3) {
	if (classes$3 === void 0) classes$3 = {};
	var containerClasses = {
		containerRoot: true,
		containerAnchorOriginTopCenter: true,
		containerAnchorOriginBottomCenter: true,
		containerAnchorOriginTopRight: true,
		containerAnchorOriginBottomRight: true,
		containerAnchorOriginTopLeft: true,
		containerAnchorOriginBottomLeft: true
	};
	return Object.keys(classes$3).filter(function(key) {
		return !containerClasses[key];
	}).reduce(function(obj, key) {
		var _extends2;
		return _extends({}, obj, (_extends2 = {}, _extends2[key] = classes$3[key], _extends2));
	}, {});
};
var noOp$1 = function noOp$2() {};
/**
* Credit to MUI team @ https://mui.com
* Safe chained function.
*
* Will only create a new function if needed,
* otherwise will pass back existing functions or null.
*/
function createChainedFunction(funcs, snackbarId) {
	return funcs.reduce(function(acc, func) {
		if (func === null || func === void 0) return acc;
		return function chainedFunction() {
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
			var argums = [].concat(args);
			if (snackbarId && argums.indexOf(snackbarId) === -1) argums.push(snackbarId);
			acc.apply(this, argums);
			func.apply(this, argums);
		};
	}, noOp$1);
}
/**
* Credit to MUI team @ https://mui.com
* https://github.com/facebook/react/issues/14099#issuecomment-440013892
*/
var useEnhancedEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function useEventCallback(fn) {
	var ref = (0, import_react.useRef)(fn);
	useEnhancedEffect(function() {
		ref.current = fn;
	});
	return (0, import_react.useCallback)(function() {
		return ref.current.apply(void 0, arguments);
	}, []);
}
/**
* Credit to MUI team @ https://mui.com
*/
var Snackbar = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
	var children = props.children, className = props.className, autoHideDuration = props.autoHideDuration, _props$disableWindowB = props.disableWindowBlurListener, disableWindowBlurListener = _props$disableWindowB === void 0 ? false : _props$disableWindowB, onClose = props.onClose, id = props.id, open = props.open, _props$SnackbarProps = props.SnackbarProps, SnackbarProps = _props$SnackbarProps === void 0 ? {} : _props$SnackbarProps;
	var timerAutoHide = (0, import_react.useRef)();
	var handleClose = useEventCallback(function() {
		if (onClose) onClose.apply(void 0, arguments);
	});
	var setAutoHideTimer = useEventCallback(function(autoHideDurationParam) {
		if (!onClose || autoHideDurationParam == null) return;
		if (timerAutoHide.current) clearTimeout(timerAutoHide.current);
		timerAutoHide.current = setTimeout(function() {
			handleClose(null, "timeout", id);
		}, autoHideDurationParam);
	});
	(0, import_react.useEffect)(function() {
		if (open) setAutoHideTimer(autoHideDuration);
		return function() {
			if (timerAutoHide.current) clearTimeout(timerAutoHide.current);
		};
	}, [
		open,
		autoHideDuration,
		setAutoHideTimer
	]);
	/**
	* Pause the timer when the user is interacting with the Snackbar
	* or when the user hide the window.
	*/
	var handlePause = function handlePause$1() {
		if (timerAutoHide.current) clearTimeout(timerAutoHide.current);
	};
	/**
	* Restart the timer when the user is no longer interacting with the Snackbar
	* or when the window is shown back.
	*/
	var handleResume = (0, import_react.useCallback)(function() {
		if (autoHideDuration != null) setAutoHideTimer(autoHideDuration * .5);
	}, [autoHideDuration, setAutoHideTimer]);
	var handleMouseEnter = function handleMouseEnter$1(event) {
		if (SnackbarProps.onMouseEnter) SnackbarProps.onMouseEnter(event);
		handlePause();
	};
	var handleMouseLeave = function handleMouseLeave$1(event) {
		if (SnackbarProps.onMouseLeave) SnackbarProps.onMouseLeave(event);
		handleResume();
	};
	(0, import_react.useEffect)(function() {
		if (!disableWindowBlurListener && open) {
			window.addEventListener("focus", handleResume);
			window.addEventListener("blur", handlePause);
			return function() {
				window.removeEventListener("focus", handleResume);
				window.removeEventListener("blur", handlePause);
			};
		}
	}, [
		disableWindowBlurListener,
		handleResume,
		open
	]);
	return (0, import_react.createElement)("div", Object.assign({ ref }, SnackbarProps, {
		className: clsx_m_default(ComponentClasses.Snackbar, className),
		onMouseEnter: handleMouseEnter,
		onMouseLeave: handleMouseLeave
	}), children);
});
Snackbar.displayName = "Snackbar";
var _root;
var classes$1 = /* @__PURE__ */ makeStyles({ root: (_root = {
	display: "flex",
	flexWrap: "wrap",
	flexGrow: 1
}, _root[breakpoints.upSm] = {
	flexGrow: "initial",
	minWidth: "288px"
}, _root) });
var SnackbarContent = /* @__PURE__ */ (0, import_react.forwardRef)(function(_ref, ref) {
	var className = _ref.className, props = _objectWithoutPropertiesLoose(_ref, ["className"]);
	return import_react.createElement("div", Object.assign({
		ref,
		className: clsx_m_default(classes$1.root, className)
	}, props));
});
SnackbarContent.displayName = "SnackbarContent";
var classes$2 = /* @__PURE__ */ makeStyles({
	root: {
		backgroundColor: "#313131",
		fontSize: "0.875rem",
		lineHeight: 1.43,
		letterSpacing: "0.01071em",
		color: "#fff",
		alignItems: "center",
		padding: "6px 16px",
		borderRadius: "4px",
		boxShadow: "0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12)"
	},
	lessPadding: { paddingLeft: "20px" },
	"default": { backgroundColor: "#313131" },
	success: { backgroundColor: "#43a047" },
	error: { backgroundColor: "#d32f2f" },
	warning: { backgroundColor: "#ff9800" },
	info: { backgroundColor: "#2196f3" },
	message: {
		display: "flex",
		alignItems: "center",
		padding: "8px 0"
	},
	action: {
		display: "flex",
		alignItems: "center",
		marginLeft: "auto",
		paddingLeft: "16px",
		marginRight: "-8px"
	}
});
var ariaDescribedby = "notistack-snackbar";
var MaterialDesignContent = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, forwardedRef) {
	var id = props.id, message = props.message, componentOrFunctionAction = props.action, iconVariant = props.iconVariant, variant = props.variant, hideIconVariant = props.hideIconVariant, style = props.style, className = props.className;
	var icon = iconVariant[variant];
	var action = componentOrFunctionAction;
	if (typeof action === "function") action = action(id);
	return import_react.createElement(SnackbarContent, {
		ref: forwardedRef,
		role: "alert",
		"aria-describedby": ariaDescribedby,
		style,
		className: clsx_m_default(ComponentClasses.MuiContent, ComponentClasses.MuiContentVariant(variant), classes$2.root, classes$2[variant], className, !hideIconVariant && icon && classes$2.lessPadding)
	}, import_react.createElement("div", {
		id: ariaDescribedby,
		className: classes$2.message
	}, !hideIconVariant ? icon : null, message), action && import_react.createElement("div", { className: classes$2.action }, action));
});
MaterialDesignContent.displayName = "MaterialDesignContent";
var MaterialDesignContent$1 = /* @__PURE__ */ (0, import_react.memo)(MaterialDesignContent);
var styles = /* @__PURE__ */ makeStyles({ wrappedRoot: {
	width: "100%",
	position: "relative",
	transform: "translateX(0)",
	top: 0,
	right: 0,
	bottom: 0,
	left: 0,
	minWidth: "288px"
} });
var SnackbarItem = function SnackbarItem$1(props) {
	var timeout$1 = (0, import_react.useRef)();
	var _useState = (0, import_react.useState)(true), collapsed = _useState[0], setCollapsed = _useState[1];
	var handleClose = createChainedFunction([props.snack.onClose, props.onClose]);
	var handleEntered = function handleEntered$1() {
		if (props.snack.requestClose) handleClose(null, "instructed", props.snack.id);
	};
	var handleExitedScreen = (0, import_react.useCallback)(function() {
		timeout$1.current = setTimeout(function() {
			setCollapsed(function(col) {
				return !col;
			});
		}, 125);
	}, []);
	(0, import_react.useEffect)(function() {
		return function() {
			if (timeout$1.current) clearTimeout(timeout$1.current);
		};
	}, []);
	var snack = props.snack, allClasses = props.classes, _props$Component = props.Component, Component$1 = _props$Component === void 0 ? MaterialDesignContent$1 : _props$Component;
	var classes$3 = (0, import_react.useMemo)(function() {
		return keepSnackbarClassKeys(allClasses);
	}, [allClasses]);
	var open = snack.open, SnackbarProps = snack.SnackbarProps, TransitionComponent = snack.TransitionComponent, TransitionProps = snack.TransitionProps, transitionDuration = snack.transitionDuration, disableWindowBlurListener = snack.disableWindowBlurListener, componentOrFunctionContent = snack.content, otherSnack = _objectWithoutPropertiesLoose(snack, [
		"open",
		"SnackbarProps",
		"TransitionComponent",
		"TransitionProps",
		"transitionDuration",
		"disableWindowBlurListener",
		"content",
		"entered",
		"requestClose",
		"onEnter",
		"onEntered",
		"onExit",
		"onExited"
	]);
	var transitionProps = _extends({
		direction: getSlideDirection(otherSnack.anchorOrigin),
		timeout: transitionDuration
	}, TransitionProps);
	var content = componentOrFunctionContent;
	if (typeof content === "function") content = content(otherSnack.id, otherSnack.message);
	var callbacks = [
		"onEnter",
		"onEntered",
		"onExit",
		"onExited"
	].reduce(function(acc, cbName) {
		var _extends2;
		return _extends({}, acc, (_extends2 = {}, _extends2[cbName] = createChainedFunction([props.snack[cbName], props[cbName]], otherSnack.id), _extends2));
	}, {});
	return import_react.createElement(Collapse, {
		"in": collapsed,
		onExited: callbacks.onExited
	}, import_react.createElement(Snackbar, {
		open,
		id: otherSnack.id,
		disableWindowBlurListener,
		autoHideDuration: otherSnack.autoHideDuration,
		className: clsx_m_default(styles.wrappedRoot, classes$3.root, classes$3[toSnackbarAnchorOrigin(otherSnack.anchorOrigin)]),
		SnackbarProps,
		onClose: handleClose
	}, import_react.createElement(TransitionComponent, Object.assign({}, transitionProps, {
		appear: true,
		"in": open,
		onExit: callbacks.onExit,
		onExited: handleExitedScreen,
		onEnter: callbacks.onEnter,
		onEntered: createChainedFunction([callbacks.onEntered, handleEntered], otherSnack.id)
	}), content || import_react.createElement(Component$1, Object.assign({}, otherSnack)))));
};
var _root$1, _rootDense, _left, _right, _center;
var indents = {
	view: {
		"default": 20,
		dense: 4
	},
	snackbar: {
		"default": 6,
		dense: 2
	}
};
var collapseWrapper = "." + ComponentClasses.CollapseWrapper;
var xsWidthMargin = 16;
var styles$1 = /* @__PURE__ */ makeStyles({
	root: (_root$1 = {
		boxSizing: "border-box",
		display: "flex",
		maxHeight: "100%",
		position: "fixed",
		zIndex: 1400,
		height: "auto",
		width: "auto",
		transition: /* @__PURE__ */ createTransition([
			"top",
			"right",
			"bottom",
			"left",
			"max-width"
		], {
			duration: 300,
			easing: "ease"
		}),
		pointerEvents: "none"
	}, _root$1[collapseWrapper] = {
		padding: indents.snackbar["default"] + "px 0px",
		transition: "padding 300ms ease 0ms"
	}, _root$1.maxWidth = "calc(100% - " + indents.view["default"] * 2 + "px)", _root$1[breakpoints.downXs] = {
		width: "100%",
		maxWidth: "calc(100% - " + xsWidthMargin * 2 + "px)"
	}, _root$1),
	rootDense: (_rootDense = {}, _rootDense[collapseWrapper] = { padding: indents.snackbar.dense + "px 0px" }, _rootDense),
	top: {
		top: indents.view["default"] - indents.snackbar["default"] + "px",
		flexDirection: "column"
	},
	bottom: {
		bottom: indents.view["default"] - indents.snackbar["default"] + "px",
		flexDirection: "column-reverse"
	},
	left: (_left = { left: indents.view["default"] + "px" }, _left[breakpoints.upSm] = { alignItems: "flex-start" }, _left[breakpoints.downXs] = { left: xsWidthMargin + "px" }, _left),
	right: (_right = { right: indents.view["default"] + "px" }, _right[breakpoints.upSm] = { alignItems: "flex-end" }, _right[breakpoints.downXs] = { right: xsWidthMargin + "px" }, _right),
	center: (_center = {
		left: "50%",
		transform: "translateX(-50%)"
	}, _center[breakpoints.upSm] = { alignItems: "center" }, _center)
});
var SnackbarContainer$1 = /* @__PURE__ */ (0, import_react.memo)(function SnackbarContainer(props) {
	var _props$classes = props.classes, classes$3 = _props$classes === void 0 ? {} : _props$classes, anchorOrigin = props.anchorOrigin, dense = props.dense, children = props.children;
	var combinedClassname = clsx_m_default(ComponentClasses.SnackbarContainer, styles$1[anchorOrigin.vertical], styles$1[anchorOrigin.horizontal], styles$1.root, classes$3.containerRoot, classes$3["containerAnchorOrigin" + originKeyExtractor(anchorOrigin)], dense && styles$1.rootDense);
	return import_react.createElement("div", { className: combinedClassname }, children);
});
var __DEV__ = true;
var messages = { NO_PERSIST_ALL: "Reached maxSnack while all enqueued snackbars have 'persist' flag. Notistack will dismiss the oldest snackbar anyway to allow other ones in the queue to be presented." };
var warning = (function(messageKey) {
	if (!__DEV__) return;
	var message = messages[messageKey];
	if (typeof console !== "undefined") console.error("WARNING - notistack: " + message);
	try {
		throw new Error(message);
	} catch (x) {}
});
var isOptions = function isOptions$1(messageOrOptions) {
	return !(typeof messageOrOptions === "string" || (0, import_react.isValidElement)(messageOrOptions));
};
var enqueueSnackbar;
var closeSnackbar;
var SnackbarProvider = /* @__PURE__ */ function(_Component) {
	_inheritsLoose(SnackbarProvider$1, _Component);
	function SnackbarProvider$1(props) {
		var _this = _Component.call(this, props) || this;
		/**
		* Adds a new snackbar to the queue to be presented.
		* Returns generated or user defined key referencing the new snackbar or null
		*/
		_this.enqueueSnackbar = function(messageOrOptions, optsOrUndefined) {
			if (optsOrUndefined === void 0) optsOrUndefined = {};
			if (messageOrOptions === void 0 || messageOrOptions === null) throw new Error("enqueueSnackbar called with invalid argument");
			var opts = isOptions(messageOrOptions) ? messageOrOptions : optsOrUndefined;
			var message = isOptions(messageOrOptions) ? messageOrOptions.message : messageOrOptions;
			var key = opts.key, preventDuplicate = opts.preventDuplicate, options = _objectWithoutPropertiesLoose(opts, ["key", "preventDuplicate"]);
			var hasSpecifiedKey = isDefined(key);
			var id = hasSpecifiedKey ? key : (/* @__PURE__ */ new Date()).getTime() + Math.random();
			var merger = merge(options, _this.props);
			var snack = _extends({ id }, options, {
				message,
				open: true,
				entered: false,
				requestClose: false,
				persist: merger("persist"),
				action: merger("action"),
				content: merger("content"),
				variant: merger("variant"),
				anchorOrigin: merger("anchorOrigin"),
				disableWindowBlurListener: merger("disableWindowBlurListener"),
				autoHideDuration: merger("autoHideDuration"),
				hideIconVariant: merger("hideIconVariant"),
				TransitionComponent: merger("TransitionComponent"),
				transitionDuration: merger("transitionDuration"),
				TransitionProps: merger("TransitionProps", true),
				iconVariant: merger("iconVariant", true),
				style: merger("style", true),
				SnackbarProps: merger("SnackbarProps", true),
				className: clsx_m_default(_this.props.className, options.className)
			});
			if (snack.persist) snack.autoHideDuration = void 0;
			_this.setState(function(state) {
				if (preventDuplicate === void 0 && _this.props.preventDuplicate || preventDuplicate) {
					var compareFunction = function compareFunction$1(item) {
						return hasSpecifiedKey ? item.id === id : item.message === message;
					};
					var inQueue = state.queue.findIndex(compareFunction) > -1;
					var inView = state.snacks.findIndex(compareFunction) > -1;
					if (inQueue || inView) return state;
				}
				return _this.handleDisplaySnack(_extends({}, state, { queue: [].concat(state.queue, [snack]) }));
			});
			return id;
		};
		/**
		* Reducer: Display snack if there's space for it. Otherwise, immediately
		* begin dismissing the oldest message to start showing the new one.
		*/
		_this.handleDisplaySnack = function(state) {
			if (state.snacks.length >= _this.maxSnack) return _this.handleDismissOldest(state);
			return _this.processQueue(state);
		};
		/**
		* Reducer: Display items (notifications) in the queue if there's space for them.
		*/
		_this.processQueue = function(state) {
			var queue = state.queue, snacks = state.snacks;
			if (queue.length > 0) return _extends({}, state, {
				snacks: [].concat(snacks, [queue[0]]),
				queue: queue.slice(1, queue.length)
			});
			return state;
		};
		/**
		* Reducer: Hide oldest snackbar on the screen because there exists a new one which we have to display.
		* (ignoring the one with 'persist' flag. i.e. explicitly told by user not to get dismissed).
		*
		* Note 1: If there is already a message leaving the screen, no new messages are dismissed.
		* Note 2: If the oldest message has not yet entered the screen, only a request to close the
		*         snackbar is made. Once it entered the screen, it will be immediately dismissed.
		*/
		_this.handleDismissOldest = function(state) {
			if (state.snacks.some(function(item) {
				return !item.open || item.requestClose;
			})) return state;
			var popped = false;
			var ignore = false;
			if (state.snacks.reduce(function(acc, current) {
				return acc + (current.open && current.persist ? 1 : 0);
			}, 0) === _this.maxSnack) {
				warning("NO_PERSIST_ALL");
				ignore = true;
			}
			var snacks = state.snacks.map(function(item) {
				if (!popped && (!item.persist || ignore)) {
					popped = true;
					if (!item.entered) return _extends({}, item, { requestClose: true });
					if (item.onClose) item.onClose(null, "maxsnack", item.id);
					if (_this.props.onClose) _this.props.onClose(null, "maxsnack", item.id);
					return _extends({}, item, { open: false });
				}
				return _extends({}, item);
			});
			return _extends({}, state, { snacks });
		};
		/**
		* Set the entered state of the snackbar with the given key.
		*/
		_this.handleEnteredSnack = function(node, isAppearing, key) {
			if (!isDefined(key)) throw new Error("handleEnteredSnack Cannot be called with undefined key");
			_this.setState(function(_ref) {
				return { snacks: _ref.snacks.map(function(item) {
					return item.id === key ? _extends({}, item, { entered: true }) : _extends({}, item);
				}) };
			});
		};
		/**
		* Hide a snackbar after its timeout.
		*/
		_this.handleCloseSnack = function(event, reason, key) {
			if (_this.props.onClose) _this.props.onClose(event, reason, key);
			var shouldCloseAll = key === void 0;
			_this.setState(function(_ref2) {
				var snacks = _ref2.snacks, queue = _ref2.queue;
				return {
					snacks: snacks.map(function(item) {
						if (!shouldCloseAll && item.id !== key) return _extends({}, item);
						return item.entered ? _extends({}, item, { open: false }) : _extends({}, item, { requestClose: true });
					}),
					queue: queue.filter(function(item) {
						return item.id !== key;
					})
				};
			});
		};
		/**
		* Close snackbar with the given key
		*/
		_this.closeSnackbar = function(key) {
			var toBeClosed = _this.state.snacks.find(function(item) {
				return item.id === key;
			});
			if (isDefined(key) && toBeClosed && toBeClosed.onClose) toBeClosed.onClose(null, "instructed", key);
			_this.handleCloseSnack(null, "instructed", key);
		};
		/**
		* When we set open attribute of a snackbar to false (i.e. after we hide a snackbar),
		* it leaves the screen and immediately after leaving animation is done, this method
		* gets called. We remove the hidden snackbar from state and then display notifications
		* waiting in the queue (if any). If after this process the queue is not empty, the
		* oldest message is dismissed.
		*/
		_this.handleExitedSnack = function(node, key) {
			if (!isDefined(key)) throw new Error("handleExitedSnack Cannot be called with undefined key");
			_this.setState(function(state) {
				var newState = _this.processQueue(_extends({}, state, { snacks: state.snacks.filter(function(item) {
					return item.id !== key;
				}) }));
				if (newState.queue.length === 0) return newState;
				return _this.handleDismissOldest(newState);
			});
		};
		enqueueSnackbar = _this.enqueueSnackbar;
		closeSnackbar = _this.closeSnackbar;
		_this.state = {
			snacks: [],
			queue: [],
			contextValue: {
				enqueueSnackbar: _this.enqueueSnackbar.bind(_assertThisInitialized(_this)),
				closeSnackbar: _this.closeSnackbar.bind(_assertThisInitialized(_this))
			}
		};
		return _this;
	}
	var _proto = SnackbarProvider$1.prototype;
	_proto.render = function render() {
		var _this2 = this;
		var contextValue = this.state.contextValue;
		var _this$props = this.props, domRoot = _this$props.domRoot, children = _this$props.children, _this$props$dense = _this$props.dense, dense = _this$props$dense === void 0 ? false : _this$props$dense, _this$props$Component = _this$props.Components, Components = _this$props$Component === void 0 ? {} : _this$props$Component, classes$3 = _this$props.classes;
		var categ = this.state.snacks.reduce(function(acc, current) {
			var _extends2;
			var category = originKeyExtractor(current.anchorOrigin);
			var existingOfCategory = acc[category] || [];
			return _extends({}, acc, (_extends2 = {}, _extends2[category] = [].concat(existingOfCategory, [current]), _extends2));
		}, {});
		var snackbars = Object.keys(categ).map(function(origin) {
			var snacks = categ[origin];
			var nomineeSnack = snacks[0];
			return import_react.createElement(SnackbarContainer$1, {
				key: origin,
				dense,
				anchorOrigin: nomineeSnack.anchorOrigin,
				classes: classes$3
			}, snacks.map(function(snack) {
				return import_react.createElement(SnackbarItem, {
					key: snack.id,
					snack,
					classes: classes$3,
					Component: Components[snack.variant],
					onClose: _this2.handleCloseSnack,
					onEnter: _this2.props.onEnter,
					onExit: _this2.props.onExit,
					onExited: createChainedFunction([_this2.handleExitedSnack, _this2.props.onExited], snack.id),
					onEntered: createChainedFunction([_this2.handleEnteredSnack, _this2.props.onEntered], snack.id)
				});
			}));
		});
		return import_react.createElement(SnackbarContext.Provider, { value: contextValue }, children, domRoot ? (0, import_react_dom.createPortal)(snackbars, domRoot) : snackbars);
	};
	_createClass(SnackbarProvider$1, [{
		key: "maxSnack",
		get: function get() {
			return this.props.maxSnack || defaults.maxSnack;
		}
	}]);
	return SnackbarProvider$1;
}(import_react.Component);
var useSnackbar = (function() {
	return (0, import_react.useContext)(SnackbarContext);
});

//#endregion
export { MaterialDesignContent$1 as MaterialDesignContent, SnackbarContent, SnackbarProvider, Transition, closeSnackbar, enqueueSnackbar, useSnackbar };
//# sourceMappingURL=notistack.js.map